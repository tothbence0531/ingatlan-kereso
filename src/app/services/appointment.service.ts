import { inject, Injectable, Injector } from '@angular/core';
import {
  first,
  firstValueFrom,
  map,
  Observable,
  of,
  switchMap,
  take,
} from 'rxjs';
import { Appointment } from '../models/appointment.model';
import { AuthService } from './auth.service';
import {
  addDoc,
  Firestore,
  where,
  query,
  getDocs,
  deleteDoc,
} from '@angular/fire/firestore';
import { collection, doc, getDoc, updateDoc } from 'firebase/firestore';
import { AppUser } from '../models/user.model';
import { User } from '@angular/fire/auth';
import { PropertyService } from './property.service';

@Injectable({
  providedIn: 'root',
})
export class AppointmentService {
  private readonly appointmentCollection;
  private readonly userCollection;
  private currentUser$: Observable<User | null> = of(null);

  constructor(
    private authservice: AuthService,
    private firestore: Firestore,
    private propertyService: PropertyService
  ) {
    this.firestore = inject(Firestore);
    this.appointmentCollection = collection(this.firestore, 'Appointments');
    this.userCollection = collection(this.firestore, 'Users');
    this.currentUser$ = this.authservice.getCurrentUser();
  }

  /**
   * adds appointment to firestore and updates the user's appointments
   * throws an error if the user is not logged in or is not a seller
   * id is random and is generated by firestore
   * @param appointment appointment to add
   * @returns promise that resolves to the added appointment
   */
  async addAppointment(
    appointment: Omit<Appointment, 'owner'>
  ): Promise<Appointment> {
    try {
      const userData = await firstValueFrom(
        this.authservice.getCurrentUserData$().pipe(take(1))
      );

      if (!userData) {
        throw new Error('Felhasználó nincs bejelentkezve');
      }

      const newAppointment = {
        ...appointment,
        owner: userData.uid,
      };

      const appointmentDocRef = await addDoc(
        this.appointmentCollection,
        newAppointment
      );
      const appointmentId = appointmentDocRef.id;

      updateDoc(appointmentDocRef, { id: appointmentId });

      const savedAppointment: Appointment = {
        ...newAppointment,
        id: appointmentId,
      };

      const userDocRef = doc(this.userCollection, userData.uid);
      const userDoc = await getDoc(userDocRef);

      if (userDoc.exists()) {
        const userData = userDoc.data() as AppUser;
        const appointments = userData.appointments || [];
        appointments.push(appointmentId);
        await updateDoc(userDocRef, { appointments });
      }

      return savedAppointment;
    } catch (error) {
      console.error('Error in appointment addition process:', error);
      throw error;
    }
  }

  getAppointmentsFromCurrentUser(): Observable<Appointment[]> {
    return this.authservice.getCurrentUser().pipe(
      switchMap(async (user) => {
        if (!user) return of([]);

        try {
          const userDocRef = doc(this.userCollection, user.uid);
          const userDoc = await getDoc(userDocRef);
          if (!userDoc.exists()) return of([]);
          const userData = userDoc.data() as AppUser;

          const appointments: Appointment[] = [];
          const q = query(
            this.appointmentCollection,
            where('owner', '==', user.uid)
          );
          const querySnapshot = await getDocs(q);

          querySnapshot.forEach((doc) => {
            const appointment = doc.data() as Appointment;
            appointments.push(appointment);
          });

          if (userData.role === 'seller' && userData.listings?.length) {
            const batchSize = 10;
            const batches = [];

            for (let i = 0; i < userData.listings.length; i += batchSize) {
              const batch = userData.listings.slice(i, i + batchSize);
              const q = query(
                this.appointmentCollection,
                where('propertyId', 'in', batch)
              );
              batches.push(getDocs(q));
            }

            const batchSnapshots = await Promise.all(batches);

            for (const snapshot of batchSnapshots) {
              snapshot.forEach((doc) => {
                const appointment = doc.data() as Appointment;
                if (!appointments.some((a) => a.id === appointment.id)) {
                  appointments.push(appointment);
                }
              });
            }
          }

          return of(
            appointments.sort((a, b) => {
              const aDate = new Date(a.date);
              const bDate = new Date(b.date);
              return aDate.getTime() - bDate.getTime();
            })
          );
        } catch (error) {
          console.error('Error in getAppointmentsFromCurrentUser:', error);
          return of([]);
        }
      }),
      switchMap((appointments) => appointments)
    );
  }

  async deleteAppointment(appointmentId: string): Promise<void> {
    try {
      const user = await firstValueFrom(
        this.authservice.getCurrentUser().pipe(take(1))
      );
      if (!user) throw new Error('Felhasználó nincs bejelentkezve');

      const userDocRef = doc(this.userCollection, user.uid);
      const userDoc = await getDoc(userDocRef);
      const appointmentDocRef = doc(this.appointmentCollection, appointmentId);
      const appointmentDoc = await getDoc(appointmentDocRef);
      const property$ = this.propertyService.getPropertyById(
        appointmentDoc.get('propertyId')
      );
      const property = await firstValueFrom(property$);

      if (!userDoc.exists()) {
        throw new Error('Felhasználó nincs bejelentkezve');
      }

      const userData = userDoc.data() as AppUser;
      if (
        !userData.appointments ||
        (!userData.appointments.includes(appointmentId) &&
          property?.owner !== user.uid)
      ) {
        throw new Error('Az időpont nem hozzáférhető');
      }

      await deleteDoc(appointmentDocRef);

      const appointments = userData.appointments.filter(
        (id) => id !== appointmentId
      );
      return updateDoc(userDocRef, { appointments });
    } catch (error) {
      console.error('Error in deleteAppointment:', error);
      throw error;
    }
  }
}
